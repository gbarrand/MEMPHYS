
/*
#include <AIDA/IAnalysisFactory.h>
#include <AIDA/ITreeFactory.h>
#include <AIDA/ITree.h>
#include <AIDA/IManagedObject.h>
#include <AIDA/ITuple.h>
#include <AIDA/ITupleEntry.h>

#include <iostream>

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

inline AIDA::ITuple* cast_Tuple(AIDA::ITupleEntry* aEntry) {
  //return (AIDA::ITuple*)aEntry->cast("AIDA::ITuple");
  return dynamic_cast<AIDA::ITuple*>(aEntry);
}

inline bool get_XYZ(AIDA::ITupleEntry* a_entry,double& aX,double& aY,double& aZ) {
  if(!a_entry) return false;
  AIDA::ITuple* tuple = cast_Tuple(a_entry);
  if(!tuple) return false;

  tuple->start();
  if(!tuple->next()) return false;

  aX = tuple->getDouble(0);
  aY = tuple->getDouble(1);
  aZ = tuple->getDouble(2);

  return true;
}
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
inline bool dump_tracks(AIDA::ITupleEntry* a_entry) {
  if(!a_entry) return false;
  AIDA::ITuple* tuple = cast_Tuple(a_entry);
  if(!tuple) return false;

  //if(nPart!=tracks->rows()) {
  //  std::cout << "read: nPart / tracks mismatch " 
  //              << nPart << " " << tracks->rows() << std::endl;
  //  return false;
  //}

  tuple->start();
  int irow = 0;
  while(tuple->next()) {

    int pId = tuple->getInt(0);
    int parent = tuple->getInt(1);
    float timeStart = tuple->getFloat(2);

    double dx,dy,dz;
    if(!get_XYZ((AIDA::ITupleEntry*)tuple->getObject(3),dx,dy,dz)) return false;

    double mass = tuple->getDouble(4);
    double pTot = tuple->getDouble(5);
    double ETot = tuple->getDouble(6);

    double px,py,pz;
    if(!get_XYZ((AIDA::ITupleEntry*)tuple->getObject(7),px,py,pz)) return false;

    double start_x,start_y,start_z;
    if(!get_XYZ((AIDA::ITupleEntry*)tuple->getObject(8),start_x,start_y,start_z)) return false;

    double stop_x,stop_y,stop_z;
    if(!get_XYZ((AIDA::ITupleEntry*)tuple->getObject(9),stop_x,stop_y,stop_z)) return false;

    int startVol = tuple->getInt(10);
    int stopVol = tuple->getInt(11);

    std::cout << "----> Tk{"<<irow<<"}: " 
              << " pId " << pId
              << " parent " << parent
              << " creation time " << timeStart 
              << " Volumes " << startVol << " " << stopVol << "\n"
              << " Start Pos (" << start_x 
              << "," << start_y << "," << start_z << ")\n"
              << " Stop Pos (" << stop_x 
              << "," << stop_y << "," << stop_z << ")\n"
              << " dx,dy,dz " << dx << " " << dy << " " << dz << "\n"
              << " m " << mass
              << " ETot " << ETot
              << " pTot " << pTot
              << " px,py,pz " << px << " " << py << " " << pz << "\n"
              << std::endl;

    irow++;
  }
  return true;
}

template <class H1D>
inline bool process_hits_times(AIDA::ITupleEntry* a_entry,H1D& aHisto) {
  if(!a_entry) return false;
  AIDA::ITuple* tuple = cast_Tuple(a_entry);
  if(!tuple) return false;

  tuple->start();
  while(tuple->next()) {

    float time = tuple->getFloat(0);

    aHisto.Fill(time);
  }
  return true;
}

template <class H1D>
inline bool process_hits(AIDA::ITupleEntry* a_entry,H1D& aHisto) {
  if(!a_entry) return false;

  AIDA::ITuple* tuple = cast_Tuple(a_entry);
  if(!tuple) return false;

  tuple->start();
  while(tuple->next()) {

    //int tubeId = tuple->getInt(0);
    //int totalPE = tuple->getInt(1);
    
    if(!process_hits_times((AIDA::ITupleEntry*)tuple->getObject(2),aHisto)) return false;
  }
  return true;
}

template <class H2D>
inline bool process_digits(AIDA::ITupleEntry* a_entry,H2D& aHisto) {
  if(!a_entry) return false;
  AIDA::ITuple* tuple = cast_Tuple(a_entry);
  if(!tuple) return false;

  tuple->start();
  while(tuple->next()) {

    //int tubeId = tuple->getInt(0);
    double pe = tuple->getDouble(1);
    double time = tuple->getDouble(2);
    //printf("debug : ++++ : %g %g\n",time,pe);

    aHisto.Fill(time,pe);
  }
  return true;
}
*/
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#include <inlib/rroot/file>
#include <inlib/rroot/fac>
#include <inlib/rroot/tree_manip>
#include <inlib/file>

#include <exlib/zlib>

template <class H1D,class H2D>
inline bool read_data(std::ostream& a_out,const std::string& a_file,H1D& aHisto1D,H2D& aHisto2D) {

 {bool is;
  inlib::file::is_root(a_file,is);
  if(!is) {
    a_out << "file is not a root file." << std::endl;
    return false;
  }}

  /////////////////////////////////////////////
  //// open the data file : ///////////////////
  /////////////////////////////////////////////
  bool verbose = false;
  //verbose = true;
  inlib::rroot::file rfile(a_out,a_file,verbose);
  rfile.add_unziper('Z',exlib::decompress_buffer);

  std::string stree("Event");
  inlib::rroot::fac fac(a_out);
  inlib::rroot::tree* tree = inlib::rroot::find_tree(rfile,fac,stree);      
  if(!tree) {
    a_out << "tree " << stree << " not found." << std::endl;
    return false;
  }

  inlib::uint64 nentries = tree->entries();
  if(!nentries) {
    a_out << "tree " << stree << " empty." << std::endl;
    return true;
  }

  a_out << "traitements de " << nentries << " entrees" << std::endl;

  std::vector<inlib::rroot::base_leaf*> leaves;
  tree->find_leaves(leaves);

 {inlib_vforcit(inlib::rroot::base_leaf*,leaves,it) {
    a_out << "leaf : " << (*it)->name() << " " << (*it)->title()  << " " << (*it)->s_cls() << std::endl;
  }}

#define FIND_LEAF(a__type,a__name) \
  inlib::rroot::branch* br_##a__name;\
  inlib::rroot::leaf<a__type>* leaf_##a__name;\
  if(!inlib::rroot::find_leaf(*tree,#a__name,br_##a__name,leaf_##a__name)) return false;

  FIND_LEAF(int,eventId)
  FIND_LEAF(int,nPart)
  FIND_LEAF(int,nHits)
  FIND_LEAF(int,nDigits)
  FIND_LEAF(double,sumPE)

#define READ_LEAF(a__type,a__name) \
  a__type a__name;\
  if(!inlib::rroot::read_leaf(rfile,*br_##a__name,*leaf_##a__name,ievent,a__name)) return false;

  bool dump = false;
  dump = true;
  
  for(inlib::uint32 ievent=0;ievent<nentries;ievent++){
    READ_LEAF(int,eventId)
    READ_LEAF(int,nPart)
    READ_LEAF(int,nHits)
    READ_LEAF(int,nDigits)
    READ_LEAF(double,sumPE)
    
    if(dump)
    a_out << ">>>>>>>>>>>>> Event{" << ievent << "}: "
    	      << " evt Id " << eventId 
    	      <<" #tracks: " << nPart
    	      <<" #hits: " << nHits
              <<" #digits: " << nDigits
              <<" sumPE " << sumPE
    	      << std::endl;
  }

#undef READ_LEAF
#undef FIND_LEAF
/*

  int irow = 0;
  tuple->start();
  while(tuple->next() && (irow<nentries)) {

    if(dump) {
    int eventId = tuple->getInt(0);
    //int inputEvtId = tuple->getInt(1);
    //int interMode = tuple->getInt(2);
    //int vtxVol = tuple->getInt(3);

    int nPart = tuple->getInt(5);
    //int leptonIndex = tuple->getInt(6);
    //int protonIndex = tuple->getInt(7);

    int nHits = tuple->getInt(9);
    int nDigits = tuple->getInt(11);
    double sumPE = tuple->getDouble(12);

    a_out << ">>>>>>>>>>>>> Event{" << irow << "}: "
    	      << " evt Id " << eventId 
    //	      << " evt Input Id " << inputEvtId
    //	      << "\n interaction mode " << interMode
    //	      << " start in volume " << vtxVol << "\n"
    	      <<" #tracks: " << nPart
    	      <<" #hits: " << nHits
              <<" #digits: " << nDigits
              <<" sumPE " << sumPE
    	      << std::endl;
    }

    if(!dump_tracks((AIDA::ITupleEntry*)tuple->getObject(8))) break;

    if(!process_hits((AIDA::ITupleEntry*)tuple->getObject(10),aHisto1D)) break;    
    if(!process_digits((AIDA::ITupleEntry*)tuple->getObject(13),aHisto2D)) break;

    irow++;
  }

  delete treeFactory;
*/
  delete tree;

  return true;
}
